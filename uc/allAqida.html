<!doctype html>
<html translate="no">
  <head>
    <!-- CHANGE !!! -->
    <link
      rel="canonical"
      href="https://hadithmv.github.io/books/allAqida.html"
    />
    <title>الجامع في العقائد – އެއްކުރަމުންދާ އަގީދާގެ ފޮތްތައް</title>
    <meta
      name="description"
      content="The Maldivian Platform for Translations of the Sunnah | ސުންނަތުގެ ތަރުޖަމާ މަންސަ"
    />
    <meta
      name="keywords"
      content="hadithmv,hadith mv, hadeeth mv,dhivehi,hadith,ޙަދީޘްއެމްވީ,ޙަދީޘް އެމްވީ"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta itemprop="name" content="Hadithmv" />
    <meta itemprop="description" content="ޙަދީޘްއެމްވީ" />
    <meta
      itemprop="image"
      content="https://hadithmv.github.io/img/logo/NewLogo7/hadithmv-logo-7.0-whiteBack-512px.png"
    />
    <meta property="og:title" content="Hadithmv" />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://hadithmv.github.io/img/logo/NewLogo7/hadithmv-logo-7.0-whiteBack-512px.png"
    />
    <link rel="icon" href="../img/logo/logo.svg" type="image/svg+xml" />
    <meta name="theme-color" content="#29434e" />
    <link
      href="../css/beta/ALL-COMB.min.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="../js/beta/ALL-COMB.min.js"></script>
    <!-- CHANGE !!! 
    <script src="../js/beta/json/allAqida.js"></script> -->
    <style></style>
  </head>
  <body>
    <div id="navbar-container"></div>
    <div class="dtWrapper">
      <table id="tableID" class="cards" width="100%"></table>
      <div class="footer">
        <div class="centerAlignedText">
          <button
            id="copyPageLink"
            class="customButtons"
            onclick="copyURLToClipButton();"
          >
            &nbsp; ސަފުހާގެ ލިންކު ކޮޕީކުރޭ &nbsp;
          </button>
          <button
            id="toggleFiliButton"
            class="customButtons"
            onclick="toggleFili();filiString();scrollUpTop()"
          >
            &nbsp; ފިލިތައް ދައްކާ &nbsp;
            <!-- ފޮރުވާ -->
          </button>
          <button
            id="toggleShowButton"
            class="customButtons"
            onclick="toggleShowOne();scrollUpTop()"
          >
            &nbsp; ފުޓްނޯޓު ފޮރުވާ &nbsp;
          </button>

          <button class="customButtons" onclick="copyOneOnly();">
            &nbsp; ފިއްޔާއެކު ކޮޕީ &nbsp;
          </button>

          <script>
            // If column 3 is hidden, make it visible and hide column 4. Then trigger a click on .buttons-html5, and finally restore the original visibility states. If column 4 is visible and column 3 is hidden, hide column 4 and make column 3 visible. Then trigger a click on .buttons-html5, and finally restore the original visibility states. If column 3 is visible and column 4 is hidden, trigger a click on .buttons-html5 without changing any column visibility.
            function copyOneOnly() {
              var table = $("#tableID").DataTable();

              // Get the current visibility status of columns 3 and 4
              var isVisible3 = table.column(3).visible();
              var isVisible4 = table.column(4).visible();

              // Function to change visibility and trigger export
              function changeVisibilityAndExport(showCol3, showCol4) {
                table.column(3).visible(showCol3, false);
                table.column(4).visible(showCol4, false);
                table.draw(false); // Redraw the table without resetting the paging

                // Use setTimeout to ensure the visibility changes are applied before exporting
                setTimeout(function () {
                  $(".buttons-html5").click();

                  // Restore original visibility after a short delay
                  setTimeout(function () {
                    table.column(3).visible(isVisible3, false);
                    table.column(4).visible(isVisible4, false);
                    table.draw(false);
                  }, 100);
                }, 100);
              }

              // If column 3 is hidden, make it visible and hide column 4
              if (!isVisible3) {
                changeVisibilityAndExport(true, false);
              }
              // If column 4 is visible and column 3 is hidden, hide column 4 and make column 3 visible
              else if (isVisible4 && !isVisible3) {
                changeVisibilityAndExport(true, false);
              }
              // If column 3 is visible and column 4 is hidden, just trigger the export
              else if (isVisible3 && !isVisible4) {
                $(".buttons-html5").click();
              }
            }
          </script>

          <script>
            // CHANGE !!!
            function toggleShowOne() {
              /*var isVisible = $("#tableID").DataTable().column(8).visible();
              $("#tableID").DataTable().column(8).visible(!isVisible);*/

              var isVisible = $("#tableID").DataTable().column(6).visible();
              $("#tableID").DataTable().column(6).visible(!isVisible);

              var button = document.getElementById("toggleShowButton");
              if (button.innerHTML.trim() === "&nbsp; ފުޓްނޯޓު ފޮރުވާ &nbsp;") {
                button.innerHTML = "&nbsp; ފުޓްނޯޓު ދައްކާ &nbsp;";
              } else {
                button.innerHTML = "&nbsp; ފުޓްނޯޓު ފޮރުވާ &nbsp;";
              }
            }
          </script>
          <script>
            function toggleFili() {
              var isVisible = $("#tableID").DataTable().column(3).visible();
              $("#tableID").DataTable().column(3).visible(!isVisible);

              var isVisible = $("#tableID").DataTable().column(4).visible();
              $("#tableID").DataTable().column(4).visible(!isVisible);
            }
          </script>

          <p class="rightAlignedText">
            ⚠️ ނޯޓު: މިއީ ޙަދީޘްއެމްވީގައިވާ ހުރިހާ އަގީދާ ފޮތްތައް އެއް
            ތަނަކުން ސާޗް ކުރެވޭ ސަފުހާއެވެ.
          </p>
        </div>
      </div>
    </div>
    <script type="text/javascript">
      // CHANGE !!!

      // Initialize an empty array to hold the datasets
      var dataSets = [];
      // array list of dataset files to load data from
      /*var datasetFiles = [
              "../js/beta/json/allAqida.js",
              "../js/beta/json/arbaoonNawawi.js",
            ];*/
      // Add more files as needed
      var datasetFiles = [
        "usooluSunnahAhmed.js",
        "sharhuSunnahBarbahari.js",
        "aqidatuRaziyain.js",
        "kitabulEmanAbiUbaid.js",
        "nawaqidulislam.js",
        "qawaidulArbau.js",
        "usooluSiththa.js",
        "usooluThalaatha.js",
        "sharhuSunnahBarbahari-DFK.js",
        // Add other dataset files here
      ].map((file) => `../js/beta/json/${file}`);

      // Configuration for each dataset, in order
      var datasetConfigs = [
        // Columns to keep (0-based index)
        // New order (after new column added)
        // New column with "text"
        /*{
                // allAthar
                // book	#	arText	dvText	Takhrij
                columnsToKeep: null, // Keep all columns as they are
                columnOrder: null, // Maintain the existing order of columns
                newColumns: [], // No new columns to add
              },*/
        {
          columnsToKeep: [0, 1, 2, 3],
          //columnOrder: [0, 1, 2, 3, 4], // New order for the columns after adding new columns
          //columnOrder: null, // Maintain the existing order of columns
          // Remove or set to null: columnOrder: null,
          newColumns: [{ value: "أصول السنة لأحمد" }], // Add a new column with the value "text" in each row
        },
        {
          columnsToKeep: [0, 1, 2, 3],
          newColumns: [{ value: "شرح السنة للبربهاري" }],
        },
        {
          columnsToKeep: [0, 1, 2, 3],
          newColumns: [{ value: "عقيدة الرازيين" }],
        },
        {
          columnsToKeep: [0, 3, 5, 6],
          newColumns: [{ value: "كتاب الإيمان لأبي عبيد" }],
        },
        {
          columnsToKeep: [0, 3, 4, 5],
          newColumns: [{ value: "نواقض الإسلام" }],
        },
        {
          columnsToKeep: [0, 3, 4, 5],
          newColumns: [{ value: "القواعد الأربع" }],
        },
        {
          columnsToKeep: [0, 3, 4, 5],
          newColumns: [{ value: "الأصول الستة" }],
        },
        {
          columnsToKeep: [0, 3, 4, 5],
          newColumns: [{ value: "الأصول الثلاثة" }],
        },
        {
          columnsToKeep: [0, 1, 2], // Only 3 columns to keep
          // We'll still maintain 5 columns in output
          newColumns: [{ value: "شرح السنة للبربهاري - DFK" }],
        },
        //
      ];

      // Function to process each dataset
      function processDataSet(dataset, config, filename) {
        let processedData = dataset.map((row) => {
          let newRow = [];

          // Keep only the specified columns from the original data
          config.columnsToKeep.forEach((col) => {
            newRow.push(row[col] == null ? "" : row[col]);
          });

          // Add the dataset name as the first column only if newColumns is specified
          if (config.newColumns && config.newColumns.length > 0) {
            newRow.unshift(config.newColumns[0].value);
          }

          return newRow;
        });

        // Reorder columns if a specific order is specified in the config
        if (config.columnOrder) {
          processedData = processedData.map((row) => {
            return config.columnOrder.map(
              (orderIndex) => row[orderIndex] || ""
            );
          });
        }

        // Return processed data along with the filename for identification
        return { data: processedData, filename: filename };
      }

      // Function to load all datasets
      function loadDatasets(files, configs, callback) {
        var loaded = 0;
        files.forEach(function (file, index) {
          // Create a script element to load the dataset file
          var script = document.createElement("script");
          script.src = file;
          script.onload = function () {
            // Process the loaded data and store it in dataSets array
            dataSets[index] = processDataSet(data, configs[index], file);
            loaded++;
            // If all datasets are loaded, call the callback function
            if (loaded === files.length) {
              callback();
            }
          };
          document.head.appendChild(script);
        });
      }

      // Load all datasets and then process them
      loadDatasets(datasetFiles, datasetConfigs, function () {
        // Find the indices of the two datasets we want to combine
        const barbarahiIndex = dataSets.findIndex((ds) =>
          ds.filename.includes("sharhuSunnahBarbahari.js")
        );
        const barbarahiDFKIndex = dataSets.findIndex((ds) =>
          ds.filename.includes("sharhuSunnahBarbahari-DFK.js")
        );

        // If both datasets are found, combine them
        if (barbarahiIndex !== -1 && barbarahiDFKIndex !== -1) {
          // Combine the datasets
          dataSets[barbarahiDFKIndex].data = dataSets[
            barbarahiDFKIndex
          ].data.map((row, index) => {
            const barbarahiRow = dataSets[barbarahiIndex].data[index] || [];
            return [
              row[0], // Dataset name
              barbarahiRow[1] || "", // First column from sharhuSunnahBarbahari
              barbarahiRow[2] || "", // Second column from sharhuSunnahBarbahari
              row[1] || "", // First column from sharhuSunnahBarbahari-DFK
              row[2] || "", // Second column from sharhuSunnahBarbahari-DFK
            ];
          });
        }

        // Flatten the dataSets array to get a single array of all rows
        var combinedDataSet = dataSets.flatMap((ds) => ds.data);

        // Log the combined dataset to the console. uncomment this to see the object array
        // console.log(combinedDataSet);

        // Initialize the DataTable with the combined dataset and specified configuration
        var table = new DataTable("#tableID", {
          ...DTconfig, // Existing DataTable configuration spreadd from external file source
          data: combinedDataSet, // Set the combined dataset as the data for the table

          //columns: [null, null, null, null, null],
          /*columns: [
                  { title: "New Column Title" }, // Title for the new column ? added in the second dataset ? or just title
                  { title: "Column 1" },
                  { title: "Column 2" },
                  { title: "Column 3" },
                  { title: "Column 4" },
                ],*/

          /*});
            });*/

          //

          // book	#	arText	dvText	Takhrij
          columns: [
            { title: "ފޮތް އަރަބިން" },
            {
              title: "ފޮތް ދިވެހިން",
              data: 0,
              render: (data) =>
                data
                  .replace(
                    "أصول السنة لأحمد",
                    "އަޙްމަދުގެ ސުންނަތުގެ އުސޫލުތައް"
                  )
                  .replace(
                    "شرح السنة للبربهاري - DFK",
                    "ބަރްބަހާރީގެ ސުންނަތުގެ ޝަރަހަ - DFK"
                  )
                  .replace(
                    "شرح السنة للبربهاري",
                    "ބަރްބަހާރީގެ ސުންނަތުގެ ޝަރަހަ"
                  )
                  .replace("عقيدة الرازيين", "ދެ ރާޒީންގެ އަގީދާ")
                  .replace(
                    "كتاب الإيمان لأبي عبيد",
                    "އަބޫ ޢުބައިދުގެ އީމާންކަމުގެ ފޮތް"
                  )
                  .replace("نواقض الإسلام", "އިސްލާމްކަން ގެއްލޭ ކަންތައް")
                  .replace("القواعد الأربع", "ހަތަރު ގަވާއިދު")
                  .replace("الأصول الستة", "ހަ އުސޫލު")
                  .replace("الأصول الثلاثة", "ތިން އުސޫލު"),
              visible: false,
            },
            { title: "#", data: 1 },
            {
              title: "އަރަބި ލިޔުން",
              data: 2,
              searchable: false,
              visible: false, //FOR ALL TABLES
            },
            {
              title: "އަރަބި ފިލިނުޖަހާ",
              // CHANGE !!!
              data: 2,
              render: (data) => removeThashkeel(data),
            },
            {
              title: "ދިވެހި ލިޔުން",
              data: 3,
            },
            { title: "ތަޚްރީޖު", data: 4, searchable: true },
          ],
          columnDefs: [
            {
              targets: [6],
              render: (data) =>
                data !== ""
                  ? "ـــــــــــــــــــــــــــ\t<br>" +
                    data.replace(/\n/g, "\t<br>")
                  : data,
            },
            {
              searchPanes: {
                show: true,
              },
              targets: [0, 1],
            },
            {
              targets: [2],
              render: (data) => "#" + data,
            },
            ...columnDefsconfig,
          ],
        });
        //

        // due to the way multiple js array dataset files are dynamically loaded with datatable initialize being async, the focus code is  running before the table is fully initialized and the search input code or whaterver is available. instead of changing the external config, this can be fixed moving the focus code inside the callback that initializes the DataTable below, ensure it runs after the table is fully initialized and the search input code or whatever is available in the DOM. still currently getting a initialize-dt.js:31  Uncaught TypeError: Cannot read properties of null (reading 'addEventListener')

        /* from the initialize-dt.js, everything from between -
      document.addEventListener("DOMContentLoaded", function () {
        if (!isMobile) {
            $("div.dt-search .dt-input").focus();
        - till the end of that function was copied as is here, and any updates there will need to be brought here */

        // EXECUTE AFTER DATATALE IS INITIALIZED
        // document.dispatchEvent(new Event("dataTableInitialized"));
        if (!isMobile) {
          $("div.dt-search .dt-input").focus();

          table.on("page", function () {
            window.scrollTo({
              top: 0,
              behavior: "smooth",
            });
          });
        } else {
          table.on("page", function () {
            const trElement = document.querySelector("tbody tr");
            const navbarHeight = document.querySelector(".navbar").offsetHeight;

            const trPosition =
              trElement.getBoundingClientRect().top + window.pageYOffset;
            const offsetPosition = trPosition - navbarHeight;

            window.scrollTo({
              top: offsetPosition,
              behavior: "smooth",
            });
          });

          delete Hammer.defaults.cssProps.userSelect;

          Hammer(document.querySelector(".dataTable")).on(
            "swipeleft",
            function () {
              table.page("previous").draw("page");
            }
          );

          Hammer(document.querySelector(".dataTable")).on(
            "swiperight",
            function () {
              table.page("next").draw("page");
            }
          );
        }

        $(".dt-paging-input input")
          .prop("type", "search")
          .attr("placeholder", "ސަފުހާ");

        $("tbody").on("dblclick", "tr", function () {
          if (table.search() !== "") {
            table.search("").draw();
          }
          table.row(this).draw().show().select().draw(false);
        });

        $(".dt-search .dt-input").on("keyup click", function () {
          var str = $(this).val();
          str = str.replace(
            /[َ|ً|ُ|ٌ|ِ|ٍ|ْ|ّ|~|.|،|؟|-|ـ|’|”|:|؛|/{|/}|/(|/)|/[|/]|«|»|]/g,
            ""
          );
          $(this).val(str);
        });
        // END

        //
      });
      /*
            var table = new DataTable("#tableID", {
              ...DTconfig,
            });
            */
    </script>
  </body>
</html>

<!--

 cgpt: this is my datatables code

<!DOCTYPE html>
<html translate="no">
  <head>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <link
      href="https://nightly.datatables.net/css/dataTables.dataTables.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://nightly.datatables.net/js/dataTables.js"></script>

    <script src="data1.js"></script>
    <script src="data2.js"></script>
  </head>
  <body>
    <div class="container">
      <table id="example" class="display nowrap" width="100%"></table>
    </div>
    <script>
      new DataTable("#example", {
        pageLength: 10,
        columns: [{ title: "Name" }, { title: "Position" }],
        data: dataSet,
      });
    </script>
  </body>
</html>

data1.js links to an external js file and its contents are:
var dataSet = [
  ["Tiger Nixon", "System Architect"],
  ["Garrett Winters", "Accountant"],
  ["Unity Butler", "Marketing Designer"],
];

data2.js links to an external js file and its contents are:
var dataSet = [
  ["Brielle Williamson", "Integration Specialist"],
  ["Herrod Chandler", "Sales Assistant"],
  ["Rhona Davidson", "Integration Specialist"],
];

how do i get both sets of data to show on the datatable, without changing the contents of the js files?

that just repeats the data of the second set, and the first is not there at all

very good. how else could it have been done

...

compare between these codes:

<!DOCTYPE html>
<html translate="no">
  <head>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <link
      href="https://nightly.datatables.net/css/dataTables.dataTables.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://nightly.datatables.net/js/dataTables.js"></script>

    <script src="data1.js"></script>
    <script>
      // Store the first dataSet in another variable
      var dataSet1 = dataSet;
    </script>
    <script src="data2.js"></script>
    <script>
      // Store the second dataSet in another variable
      var dataSet2 = dataSet;
    </script>
  </head>
  <body>
    <div class="container">
      <table id="example" class="display nowrap" width="100%"></table>
    </div>
    <script>
      // Combine both datasets
      var combinedDataSet = dataSet1.concat(dataSet2);

      new DataTable("#example", {
        pageLength: 10,
        columns: [{ title: "Name" }, { title: "Position" }],
        data: combinedDataSet,
      });
    </script>
  </body>
</html>

...

<!DOCTYPE html>
<html translate="no">
  <head>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <link
      href="https://nightly.datatables.net/css/dataTables.dataTables.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://nightly.datatables.net/js/dataTables.js"></script>

    <script src="data1.js"></script>
    <script>
      var dataSets = [];
      dataSets.push(dataSet);
    </script>
    <script src="data2.js"></script>
    <script>
      dataSets.push(dataSet);
    </script>
  </head>
  <body>
    <div class="container">
      <table id="example" class="display nowrap" width="100%"></table>
    </div>
    <script>
      // Flatten the array of dataSets
      var combinedDataSet = [].concat.apply([], dataSets);

      new DataTable("#example", {
        pageLength: 10,
        columns: [{ title: "Name" }, { title: "Position" }],
        data: combinedDataSet,
      });
    </script>
  </body>
</html>

...

cgpt:

1. Variable Management
First Code:

It uses separate variables (dataSet1 and dataSet2) to store the datasets from data1.js and data2.js, respectively.
After loading both datasets, the code combines them using concat to form a single combinedDataSet.
Second Code:

It initializes an array (dataSets) and appends each dataset to this array as it loads them.
The code then flattens the dataSets array using [].concat.apply([], dataSets) to create a single combinedDataSet.
2. Array Handling
First Code:
The datasets are stored as separate variables and then concatenated. This is a straightforward approach if you have only two datasets.
Second Code:
The datasets are stored in an array, allowing for more flexibility and scalability if there are more datasets to combine. The [].concat.apply([], dataSets) method flattens the array of arrays, which is useful if each dataSet is itself an array of rows.
This method is more generic and can handle any number of datasets.
3. Scalability
First Code:

It is more suitable for a fixed number of datasets, as each dataset needs to be manually assigned to a variable and then combined.
Second Code:

It is more scalable and dynamic, as you can simply push each new dataset into the dataSets array without needing to manage additional variables manually.
4. Performance Considerations
First Code:
With only two datasets, the performance difference is negligible. The code is straightforward and easy to understand.
Second Code:
The second method is potentially more performant and flexible if you expect to handle more datasets in the future. The use of an array to store multiple datasets is more maintainable and easier to manage as the number of datasets increases.
Summary:
If you only have a fixed, small number of datasets to combine, the first approach is simple and direct.
If you anticipate needing to combine an unknown or larger number of datasets, the second approach is more robust and flexible, making it easier to maintain and extend in the future.

...

claude:

The main differences between these two code snippets are in how they handle and combine the datasets. Here are the key differences:

Data Storage:

First code: Uses separate variables dataSet1 and dataSet2 to store the datasets.
Second code: Uses an array dataSets to store multiple datasets.


Data Loading:

First code: Assigns each dataset directly to a variable.
Second code: Pushes each dataset into the dataSets array.


Combining Datasets:

First code: Uses concat() method to combine dataSet1 and dataSet2.
Second code: Uses [].concat.apply([], dataSets) to flatten the array of datasets.


Scalability:

First code: Limited to two datasets. Adding more would require additional variables and manual concatenation.
Second code: More scalable. Can easily accommodate additional datasets by adding more dataSets.push(dataSet) lines.


Memory Usage:

First code: Creates separate copies of each dataset.
Second code: Stores references to datasets, potentially more memory-efficient for large datasets.


Readability:

First code: More straightforward for exactly two datasets.
Second code: More abstract but more flexible for multiple datasets.



Both approaches achieve the same end result of combining datasets for use in a DataTable, but the second approach is more flexible and scalable if you need to work with an unknown number of datasets.

...

An Even More Scalable Approach:

For handling many datasets, you could use a more dynamic approach:

<!DOCTYPE html>
<html translate="no">
<head>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link href="https://nightly.datatables.net/css/dataTables.dataTables.css" rel="stylesheet" type="text/css" />
    <script src="https://nightly.datatables.net/js/dataTables.js"></script>
</head>
<body>
    <div class="container">
        <table id="example" class="display nowrap" width="100%"></table>
    </div>
    <script>
        var dataSets = [];
        var datasetFiles = ['data1.js', 'data2.js', 'data3.js', /* ... */];

        function loadDatasets(files, callback) {
            var loaded = 0;
            files.forEach(function(file) {
                var script = document.createElement('script');
                script.src = file;
                script.onload = function() {
                    dataSets.push(dataSet);
                    loaded++;
                    if (loaded === files.length) {
                        callback();
                    }
                };
                document.head.appendChild(script);
            });
        }

        loadDatasets(datasetFiles, function() {
            var combinedDataSet = [].concat.apply([], dataSets);
            new DataTable("#example", {
                pageLength: 10,
                columns: [{ title: "Name" }, { title: "Position" }],
                data: combinedDataSet,
            });
        });
    </script>
</body>
</html>

...

what if the data.js files are in a directory like  json/data1.js json/data2.js json/data3.js

To load the data.js files from a directory like json/data1.js, json/data2.js, json/data3.js, you need to update the datasetFiles array to include the correct path. Here's how you can modify the code:

var datasetFiles = ['json/data1.js', 'json/data2.js', 'json/data3.js', /* ... */];

...

my issue is
...DTconfig

is referenced in another external js file

in it is
table = new DataTable("#tableID", {
DTconfig
});

document.addEventListener("DOMContentLoaded", function () {
    $("div.dt-search .dt-input").focus();
});

yet

    $("div.dt-search .dt-input").focus();
is not working when because of the first piece of code

...

The issue with $("div.dt-search .dt-input").focus(); not working might be due to the fact that the DataTable initialization is asynchronous, especially since you are dynamically loading the datasets and initializing the table after they are loaded. The focus code is likely running before the table is fully initialized and the search input is available.

Solution
You need to ensure that the focus code runs only after the DataTable is fully initialized. You can do this by moving the focus code inside the callback that initializes the DataTable, like so:

var dataSets = [];

var datasetFiles = ["json/allAqida.js"];

function loadDatasets(files, callback) {
  var loaded = 0;
  files.forEach(function (file) {
    var script = document.createElement("script");
    script.src = file;
    script.onload = function () {
      dataSets.push(data);
      loaded++;
      if (loaded === files.length) {
        callback();
      }
    };
    document.head.appendChild(script);
  });
}

loadDatasets(datasetFiles, function () {
  var combinedDataSet = [].concat.apply([], dataSets);

  var table = new DataTable("#tableID", {
    ...DTconfig,

    data: combinedDataSet,

    columns: [
      { title: "ފޮތް އަރަބިން" },
      {
        title: "ފޮތް ދިވެހިން",
        data: 0,
        render: (data) => removeThashkeel(data),
        visible: false,
      },
      { title: "#", data: 1 },
      { title: "އަރަބި ލިޔުން", data: 2, searchable: false },
      {
        title: "އަރަބި ފިލިނުޖަހާ",
        data: 2,
        render: (data) => removeThashkeel(data),
        visible: false,
      },
      {
        title: "އަރަބި ފުޓްނޯޓުނުލާ",
        data: 2,
        render: (data) => removeSmallishFootnotes(data),
        visible: false,
        searchable: false,
      },
      {
        title: "ދިވެހި ލިޔުން",
        data: 3,
      },
      { title: "ތަޚްރީޖު", data: 4, searchable: false },
    ],
  });

  // Focus on the search input after the DataTable is initialized
  $("div.dt-search .dt-input").focus();
});

...


the datasets need to be in the order i add them

also i want to be able to choose which columns of the datasets to keep, or to remove, and be able to choose the order of the columns in a dataset

i also want to be able to create a new column in a dataset if i want, and give it a string that will be in each row of that column

this code only lets me choose which columns to keep, remove, and reorder, and create new colunmn with string, it only lets me choose these things on the combinedDataSet as a whole, not the individual datasets. i dont want to do that for the combined one, but on the individual ones before they are then combined

my datasetFiles are : ["json/allAqida.js", "json/arbaoonNawawi.js"];

for the first dataset, which already has 5 columns, i want to keep the columns as they already are in the datasetfile, in the same order they are in the datasetfile. i also dont want to create any new column for that dataset.

for the second dataset, i only want to keep the 1st, 4th, 5th and 6th column. not any other column. i also want them in that order, without the removed columns. i also want to create a new column at the beginning of this dataset, in each row should be a string of "text".

also there can be no null values in combinedDataSet, only empty strings.

newColumns: [{ title: "New Column Title", value: "text" }]

i dont need to set a title here, just a value

the title used in

columns: [
            { title: "New Column Title" }, 
            { title: "Column 1" },
            { title: "Column 2" },
            { title: "Column 3" },
            { title: "Column 4" },
          ],

is enough. it wont change

...

var dataSets = [];
var datasetFiles = ["json/allAqida.js", "json/arbaoonNawawi.js"];

// Configuration for each dataset
var datasetConfigs = [
    {
        columnsToKeep: null, // Keep all columns
        columnOrder: null, // Maintain existing order
        newColumns: [] // No new columns
    },
    {
        columnsToKeep: [0, 3, 4, 5], // Columns to keep (0-based index)
        columnOrder: [0, 1, 2, 3], // New order (after new column added)
        newColumns: [{ value: "text" }] // New column with "text"
    }
];

function loadDatasets(files, configs, callback) {
    var loaded = 0;
    files.forEach(function (file, index) {
        var script = document.createElement("script");
        script.src = file;
        script.onload = function () {
            // Process the dataset according to its configuration
            dataSets[index] = processDataSet(data, configs[index]);
            loaded++;
            if (loaded === files.length) {
                callback();
            }
        };
        document.head.appendChild(script);
    });
}

function processDataSet(dataset, config) {
    let processedData;

    if (config.columnsToKeep === null) {
        // Keep all columns and do not add new columns
        processedData = dataset.map(row => row.map(cell => cell === null ? '' : cell));
    } else {
        // Keep only specified columns
        processedData = dataset.map(row => {
            let newRow = config.columnsToKeep.map(col => row[col] === null ? '' : row[col]);
            // Add new columns with specified strings
            config.newColumns.forEach(col => {
                newRow.unshift(col.value);
            });
            return newRow;
        });

        // Reorder columns
        processedData = processedData.map(row => {
            let newRow = [];
            config.columnOrder.forEach(orderIndex => {
                newRow.push(row[orderIndex]);
            });
            return newRow;
        });
    }

    return processedData;
}

loadDatasets(datasetFiles, datasetConfigs, function () {
    var combinedDataSet = dataSets.flat();

    // Log the combined dataset to the console
    console.log(combinedDataSet);

    var table = new DataTable("#tableID", {
        ...DTconfig,
        data: combinedDataSet,
        columns: [
            { title: "New Column Title" }, // Title for the new column
            { title: "Column 1" },
            { title: "Column 2" },
            { title: "Column 3" },
            { title: "Column 4" },
        ],
    });
});

...

it doesnt work when a dataset is less than 4 columns. if that is the case, empty string columns should be created

function processDataSet(dataset, config) {
  let processedData;

  if (config.columnsToKeep === null) {
    // If no specific columns to keep, just replace nulls with empty strings
    processedData = dataset.map((row) =>
      row.map((cell) => (cell === null ? "" : cell))
    );
  } else {
    // Create a new dataset with the specified columns and padding
    processedData = dataset.map((row) => {
      let newRow = config.columnsToKeep.map((col) =>
        row[col] === null ? "" : row[col]
      );

      // Add new columns at the beginning
      config.newColumns.forEach((col) => {
        newRow.unshift(col.value);
      });

      // Pad the row to ensure it has the correct number of columns
      const expectedColumnCount = config.columnOrder.length;
      while (newRow.length < expectedColumnCount) {
        newRow.push("");
      }

      return newRow;
    });

    // Reorder columns according to columnOrder
    processedData = processedData.map((row) => {
      let newRow = [];
      config.columnOrder.forEach((orderIndex) => {
        newRow.push(row[orderIndex] || ""); // Ensure no undefined values
      });
      return newRow;
    });
  }

  return processedData;
}


...

what i want to do is combine and modify the resulting data of sharhuSunnahBarbahari-DFK like so:

from sharhuSunnahBarbahari, bring its first 2 columns before the 2 columns of sharhuSunnahBarbahari-DFK

...

using this:

claude:

function processDataSet(dataset, config, filename) {
        let processedData = dataset.map((row) => {
          let newRow = ["", "", "", "", ""];

          config.columnsToKeep.forEach((col, index) => {
            newRow[index + 1] = row[col] == null ? "" : row[col];
          });

          newRow[0] = config.newColumns[0].value;

          return newRow;
        });

        if (config.columnOrder) {
          processedData = processedData.map((row) => {
            return config.columnOrder.map(
              (orderIndex) => row[orderIndex] || ""
            );
          });
        }

        return { data: processedData, filename: filename };
      }

      function loadDatasets(files, configs, callback) {
        var loaded = 0;
        files.forEach(function (file, index) {
          var script = document.createElement("script");
          script.src = file;
          script.onload = function () {
            dataSets[index] = processDataSet(data, configs[index], file);
            loaded++;
            if (loaded === files.length) {
              callback();
            }
          };
          document.head.appendChild(script);
        });
      }

      loadDatasets(datasetFiles, datasetConfigs, function () {
        // Find the indices of the two datasets we want to combine
        const barbarahiIndex = dataSets.findIndex(ds => ds.filename.includes("sharhuSunnahBarbahari.js"));
        const barbarahiDFKIndex = dataSets.findIndex(ds => ds.filename.includes("sharhuSunnahBarbahari-DFK.js"));

        if (barbarahiIndex !== -1 && barbarahiDFKIndex !== -1) {
          // Combine the datasets
          dataSets[barbarahiDFKIndex].data = dataSets[barbarahiDFKIndex].data.map((row, index) => {
            const barbarahiRow = dataSets[barbarahiIndex].data[index] || [];
            return [
              row[0],
              barbarahiRow[1] || "",
              barbarahiRow[2] || "",
              row[1] || "",
              row[2] || ""
            ];
          });
        }

        var combinedDataSet = dataSets.flatMap(ds => ds.data);

        ...

        not using this:

        
cgpt code:
function loadDatasets(files, configs, callback) {
  var loaded = 0;
  files.forEach(function (file, index) {
    var script = document.createElement("script");
    script.src = file;
    script.onload = function () {
      if (file.includes("sharhuSunnahBarbahari.js")) {
        // Store the first two columns of sharhuSunnahBarbahari data
        sharhuSunnahBarbahariData = data.map((row) => [row[0], row[1]]);
      } else if (file.includes("sharhuSunnahBarbahari-DFK.js")) {
        // Combine sharhuSunnahBarbahari data with sharhuSunnahBarbahari-DFK data
        let dfkData = data.map((row, i) => [...sharhuSunnahBarbahariData[i], row[1], row[2]]);
        dataSets[index] = processDataSet(dfkData, configs[index]);
      } else {
        // Process other datasets normally
        dataSets[index] = processDataSet(data, configs[index]);
      }
      loaded++;
      if (loaded === files.length) {
        callback(); // When all files are loaded, execute the callback
      }
    };
    document.head.appendChild(script);
  });
}

function processDataSet(dataset, config) {
  let processedData = dataset.map((row) => {
    let newRow = ["", "", "", "", ""];
    config.columnsToKeep.forEach((col, index) => {
      newRow[index + 1] = row[col] == null ? "" : row[col];
    });
    newRow[0] = config.newColumns[0].value;
    return newRow;
  });

  if (config.columnOrder) {
    processedData = processedData.map((row) => {
      return config.columnOrder.map((orderIndex) => row[orderIndex] || "");
    });
  }

  return processedData;
}

loadDatasets(datasetFiles, datasetConfigs, function () {
  var combinedDataSet = dataSets.flat();
  var table = new DataTable("#tableID", {
    ...DTconfig,
    data: combinedDataSet,
  });
});

...


what if i dont want to create a new column with string for a particular data set 

for example

newColumns: [{ value: "أصول السنة لأحمد" }],

i dont want a new column with "أصول السنة لأحمد"

...

function processDataSet(dataset, config, filename) {
  let processedData = dataset.map((row) => {
    let newRow = [];

    // Keep only the specified columns from the original data
    config.columnsToKeep.forEach((col) => {
      newRow.push(row[col] == null ? "" : row[col]);
    });

    // Add the dataset name as the first column only if newColumns is specified
    if (config.newColumns && config.newColumns.length > 0) {
      newRow.unshift(config.newColumns[0].value);
    }

    return newRow;
  });

  // Reorder columns if a specific order is specified in the config
  if (config.columnOrder) {
    processedData = processedData.map((row) => {
      return config.columnOrder.map((orderIndex) => row[orderIndex] || "");
    });
  }

  // Return processed data along with the filename for identification
  return { data: processedData, filename: filename };
}
-->
